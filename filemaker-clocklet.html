<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FileMaker Clocklet Control</title>
    <style>
        /* Embedded Clocklet CSS - Minimal version for standalone use */
        .clocklet-container,
        .clocklet,
        .clocklet-plate,
        .clocklet-dial,
        .clocklet-hand,
        .clocklet-hand-origin,
        .clocklet-tick {
            touch-action: manipulation;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            box-sizing: border-box;
            position: absolute;
            font-size: inherit;
        }

        .clocklet-container {
            position: static;
            display: block;
            width: auto;
            height: auto;
        }

        .clocklet {
            position: relative;
            font-size: 16px;
            width: 270px;
            height: 270px;
            margin: 8px auto;
            padding: 8px;
        }

        .clocklet-plate {
            position: relative;
            height: 100%;
            border-radius: 50%;
            background-color: transparent;
        }

        .clocklet-dial {
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            margin: auto;
            border-radius: 50%;
        }

        .clocklet-hand,
        .clocklet-tick,
        .clocklet-hand-origin {
            z-index: 1;
        }

        .clocklet-hand {
            left: 0;
            top: 6.4%;
            right: 0;
            bottom: 50%;
            margin: auto;
            transform-origin: 50% 100%;
            background-color: #a1ddff;
        }

        .clocklet-tick {
            width: 1.75em;
            height: 1.75em;
            margin: -0.875em;
            border-radius: 50%;
            padding: 0;
            outline: 0;
            border: 0;
            cursor: pointer;
            background-color: transparent;
            color: inherit;
            font-family: inherit;
            font-weight: inherit;
        }

        .clocklet-tick::before {
            content: attr(data-clocklet-tick-value);
        }

        .clocklet-tick--selected {
            background-color: #57c2ff;
            color: #fff;
        }

        .clocklet-tick:hover {
            background-color: #7ccfff;
        }

        .clocklet-hand-origin {
            left: calc(50% - 5px);
            top: calc(50% - 5px);
            right: calc(50% - 5px);
            bottom: calc(50% - 5px);
            border-radius: 50%;
            background-color: #0F3150;
        }

        .clocklet-dial--hour {
            width: calc(40% + 56px);
            height: calc(40% + 56px);
            /*background-color: #e9fdf1;*/
            background-image: conic-gradient(from 210deg at center, #F9F9F9, #E1E1E1 )
        }

        .clocklet-hand--hour {
            width: 8px;
            background-color: #0F3150;
        }

        .clocklet-tick--hour[data-clocklet-tick-value="0"]::before {
            content: "12";
        }

        .clocklet-dial--minute {
            width: 100%;
            height: 100%;
            background-color: #E3E3E3;
        }

        .clocklet-hand--minute {
            width: 2px;
            background-color: #0F3150;
        }

        /* Time display */
        .time-display {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin: 20px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: transparent;
        }
    </style>
</head>
<body>
    <!--div class="time-display" id="timeDisplay">12:00</div-->
    
    <div class="clocklet-container">
        <div class="clocklet" id="clocklet">
            <div class="clocklet-plate">
                <div class="clocklet-dial clocklet-dial--minute">
                    <div class="clocklet-hand clocklet-hand--minute"></div>
                    <!-- Quarter hour ticks: 0, 15, 30, 45 -->
                    <button class="clocklet-tick clocklet-tick--minute" type="button" data-clocklet-tick-value="0" style="left:50%;top:11%"></button>
                    <button class="clocklet-tick clocklet-tick--minute" type="button" data-clocklet-tick-value="15" style="left:89%;top:50%"></button>
                    <button class="clocklet-tick clocklet-tick--minute" type="button" data-clocklet-tick-value="30" style="left:50%;top:89%"></button>
                    <button class="clocklet-tick clocklet-tick--minute" type="button" data-clocklet-tick-value="45" style="left:11%;top:50%"></button>
                </div>
                <div class="clocklet-dial clocklet-dial--hour">
                    <div class="clocklet-hand clocklet-hand--hour"></div>
                </div>
                <div class="clocklet-hand-origin"></div>
            </div>
        </div>
    </div>

    <script>
        // FileMaker Clocklet Control
        class FileMakerClocklet {
            constructor() {
                // Default working hours (can be overridden)
                this.workingHours = this.parseWorkingHours();
                
                this.currentHour = this.workingHours.start;
                this.currentMinute = 0;
                this.dragging = false;
                
                // Unique instance identifier
                this.instanceId = this.getInstanceId();
                
                // Debouncing for FileMaker notifications
                this.notificationTimeout = null;
                
                this.hourHand = document.querySelector('.clocklet-hand--hour');
                this.minuteHand = document.querySelector('.clocklet-hand--minute');
                
                this.generateHourTicks();
                this.initializeEventListeners();
                this.updateHands();
                
                // Signal to FileMaker that control is ready
                this.notifyFileMakerReady();
            }
            
            parseWorkingHours() {
                // Method 1: URL Parameters
                const urlParams = new URLSearchParams(window.location.search);
                const startHour = parseInt(urlParams.get('startHour')) || 9;
                const endHour = parseInt(urlParams.get('endHour')) || 17;
                
                return {
                    start: startHour,
                    end: endHour,
                    hours: this.generateHourRange(startHour, endHour)
                };
            }
            
            getInstanceId() {
                // Method 1: URL parameter
                const urlParams = new URLSearchParams(window.location.search);
                const urlId = urlParams.get('instanceId');
                if (urlId) return urlId;
                
                // Method 2: Generate based on timestamp + random
                return 'clocklet_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            }
            
            generateHourRange(start, end) {
                const hours = [];
                for (let hour = start; hour <= end; hour++) {
                    hours.push(hour);
                }
                console.log('Generated hour range:', start, 'to', end, '=', hours);
                return hours;
            }
            
            generateHourTicks() {
                const hourDial = document.querySelector('.clocklet-dial--hour');
                if (!hourDial) {
                    console.error('Hour dial not found');
                    return;
                }
                
                const existingTicks = hourDial.querySelectorAll('.clocklet-tick--hour');
                
                // Remove existing hour ticks (but preserve the hour hand)
                existingTicks.forEach(tick => tick.remove());
                
                // Generate ticks only for working hours at their natural positions
                console.log('Generating hour ticks for hours:', JSON.stringify(this.workingHours.hours));
                
                this.workingHours.hours.forEach((hour, index) => {
                    // Convert hour to natural clock position (12=0°, 1=30°, 2=60°, etc.)
                    // For 24-hour format: 13=1, 14=2, etc.
                    const displayHour = hour > 12 ? hour - 12 : (hour === 0 ? 12 : hour);
                    const angle = (displayHour * 30) - 90; // 30° per hour, -90° to start from top
                    const radian = (angle * Math.PI) / 180;
                    const radius = 39; // Same as original
                    
                    const x = Math.round((50 + radius * Math.cos(radian)) * 10) / 10;
                    const y = Math.round((50 + radius * Math.sin(radian)) * 10) / 10;
                    
                    console.log(`Processing hour ${index + 1}/${this.workingHours.hours.length}: ${hour} (display ${displayHour}) at position ${x}%, ${y}%`);
                    
                    const tick = document.createElement('button');
                    tick.className = 'clocklet-tick clocklet-tick--hour';
                    tick.type = 'button';
                    tick.setAttribute('data-clocklet-tick-value', hour.toString());
                    tick.style.left = `${x}%`;
                    tick.style.top = `${y}%`;
                    
                    // Add click listener
                    tick.addEventListener('click', (e) => {
                        const hourValue = parseInt(e.target.getAttribute('data-clocklet-tick-value'));
                        this.setHour(hourValue);
                    });
                    
                    hourDial.appendChild(tick);
                    console.log(`Added tick for hour ${hour} to DOM`);
                });
                
                console.log('Hour ticks generated. Total ticks now:', hourDial.querySelectorAll('.clocklet-tick--hour').length);
            }
            
            // Method 2: Global function to set working hours
            setWorkingHours(startHour, endHour) {
                console.log('Setting working hours:', startHour, 'to', endHour);
                console.log('Parameter types:', typeof startHour, typeof endHour);
                
                // Ensure parameters are numbers
                const start = parseInt(startHour);
                const end = parseInt(endHour);
                
                console.log('Converted to numbers:', start, 'to', end);
                
                this.workingHours = {
                    start: start,
                    end: end,
                    hours: this.generateHourRange(start, end)
                };
                
                console.log('Working hours array:', JSON.stringify(this.workingHours.hours));
                
                // Reset current hour if outside new range
                if (this.currentHour < start || this.currentHour > end) {
                    this.currentHour = start;
                    console.log('Reset current hour to:', this.currentHour);
                }
                
                // Regenerate ticks
                this.generateHourTicks();
                this.updateHands();
                this.notifyFileMaker();
            }
            
            initializeEventListeners() {
                // Minute tick listeners
                document.querySelectorAll('.clocklet-tick--minute').forEach(tick => {
                    tick.addEventListener('click', (e) => {
                        const minuteValue = parseInt(e.target.getAttribute('data-clocklet-tick-value'));
                        this.setMinute(minuteValue);
                    });
                });
                
                // Drag support for continuous adjustment
                this.initializeDragSupport();
            }
            
            initializeDragSupport() {
                const clocklet = document.getElementById('clocklet');
                
                clocklet.addEventListener('mousedown', (e) => this.startDrag(e));
                document.addEventListener('mousemove', (e) => this.drag(e));
                document.addEventListener('mouseup', () => this.endDrag());
                
                // Touch support
                clocklet.addEventListener('touchstart', (e) => this.startDrag(e.touches[0]));
                document.addEventListener('touchmove', (e) => this.drag(e.touches[0]));
                document.addEventListener('touchend', () => this.endDrag());
            }
            
            startDrag(event) {
                this.dragging = true;
                this.handleDrag(event);
            }
            
            drag(event) {
                if (!this.dragging) return;
                this.handleDrag(event);
            }
            
            endDrag() {
                this.dragging = false;
            }
            
            handleDrag(event) {
                const clocklet = document.getElementById('clocklet');
                const rect = clocklet.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const x = event.clientX - centerX;
                const y = event.clientY - centerY;
                const angle = Math.atan2(y, x);
                const degrees = (angle * 180 / Math.PI + 90 + 360) % 360;
                
                // Determine if closer to hour or minute dial
                const distance = Math.sqrt(x * x + y * y);
                const hourDialRadius = rect.width * 0.25;
                const minuteDialRadius = rect.width * 0.4;
                
                if (distance < hourDialRadius) {
                    // Hour adjustment - find closest working hour at natural position
                    const clockHour = Math.round(degrees / 30) % 12; // 0-11 (12, 1, 2, ..., 11)
                    const displayHour = clockHour === 0 ? 12 : clockHour; // Convert 0 to 12
                    
                    // Find matching working hours (both AM and PM versions)
                    const possibleHours = [displayHour, displayHour + 12];
                    const workingHour = possibleHours.find(h => this.workingHours.hours.includes(h));
                    
                    if (workingHour) {
                        this.setHour(workingHour);
                    }
                } else if (distance < minuteDialRadius) {
                    // Minute adjustment (snap to quarters)
                    const minuteValue = Math.round(degrees / 90) * 15;
                    this.setMinute(minuteValue % 60);
                }
            }
            
            setHour(hourValue) {
                // Direct hour value (no conversion needed)
                this.currentHour = hourValue;
                this.updateHands();
                this.notifyFileMaker();
            }
            
            setMinute(minuteValue) {
                this.currentMinute = minuteValue;
                this.updateHands();
                this.notifyFileMaker();
            }
            
            convertTo24Hour(hour) {
                // This method is no longer needed since we use direct hour values
                return hour;
            }
            
            updateHands() {
                // Update hour hand (convert to 12-hour for visual display)
                const displayHour = this.currentHour > 12 ? this.currentHour - 12 : this.currentHour;
                const hourAngle = (displayHour % 12) * 30 + (this.currentMinute / 60) * 30;
                this.hourHand.style.transform = `rotate(${hourAngle}deg)`;
                
                // Update minute hand
                const minuteAngle = this.currentMinute * 6;
                this.minuteHand.style.transform = `rotate(${minuteAngle}deg)`;
                
                // Update selected ticks
                this.updateSelectedTicks();
            }
            
            updateSelectedTicks() {
                // Clear previous selections
                document.querySelectorAll('.clocklet-tick--selected').forEach(tick => {
                    tick.classList.remove('clocklet-tick--selected');
                });
                
                // Highlight current hour tick
                const hourTick = document.querySelector(`[data-clocklet-tick-value="${this.currentHour}"].clocklet-tick--hour`);
                if (hourTick) hourTick.classList.add('clocklet-tick--selected');
                
                // Highlight current minute tick
                const minuteTick = document.querySelector(`[data-clocklet-tick-value="${this.currentMinute}"].clocklet-tick--minute`);
                if (minuteTick) minuteTick.classList.add('clocklet-tick--selected');
            }

            
            notifyFileMaker() {
                const timeString = `${this.currentHour.toString().padStart(2, '0')}:${this.currentMinute.toString().padStart(2, '0')}`;
                
                // Clear any pending timeout
                if (this.notificationTimeout) {
                    clearTimeout(this.notificationTimeout);
                    console.log('Cleared previous FileMaker notification timeout');
                }
                
                // Only set timeout - no immediate calls
                this.notificationTimeout = setTimeout(() => {
                    console.log('Calling FileMaker with time:', timeString);
                    this.actuallyNotifyFileMaker(timeString);
                }, 150); // Longer delay to ensure only final value is sent
                
                console.log('Scheduled FileMaker notification for:', timeString);
            }
            
            actuallyNotifyFileMaker(timeString) {
                // Create parameter object with instance ID and time
                const parameter = JSON.stringify({
                    instanceId: this.instanceId,
                    time: timeString
                });
                
                // FileMaker function call with fallback retry
                try {
                    if (typeof FileMaker !== 'undefined' && FileMaker.PerformScript) {
                        FileMaker.PerformScript('HandleTimeChange', parameter);
                        console.log('Successfully called FileMaker with:', parameter);
                    } else {
                        // If FileMaker not immediately available, wait a bit and try once more
                        setTimeout(() => {
                            try {
                                if (typeof FileMaker !== 'undefined' && FileMaker.PerformScript) {
                                    FileMaker.PerformScript('HandleTimeChange', parameter);
                                    console.log('Successfully called FileMaker (retry) with:', parameter);
                                }
                            } catch (retryError) {
                                console.log('FileMaker retry call failed, parameter:', parameter);
                            }
                        }, 50);
                    }
                } catch (error) {
                    console.log('FileMaker call failed, parameter:', parameter);
                }
            }
            
            notifyFileMakerReady() {
                // Signal that the control is loaded and ready for configuration
                // Use retry mechanism since FileMaker object may not be available immediately
                this.waitForFileMaker(() => {
                    try {
                        FileMaker.PerformScript('ClockletReady', '');
                    } catch (error) {
                        console.log('FileMaker ready notification failed:', error);
                    }
                });
            }
            
            waitForFileMaker(callback, maxAttempts = 20, attempt = 1) {
                // Check if FileMaker is available
                if (typeof FileMaker !== 'undefined' && FileMaker.PerformScript) {
                    callback();
                    return;
                }
                
                // If not available and we haven't exceeded max attempts, try again
                if (attempt < maxAttempts) {
                    setTimeout(() => {
                        this.waitForFileMaker(callback, maxAttempts, attempt + 1);
                    }, 100); // Wait 100ms between attempts
                } else {
                    console.log('FileMaker object not available after', maxAttempts, 'attempts');
                }
            }
            
            // Public method to set time from FileMaker
            setTime(timeString) {
                const [hours, minutes] = timeString.split(':').map(Number);
                this.currentHour = hours;
                this.currentMinute = minutes;
                this.updateHands();
            }
        }
        
        // Initialize the control
        const clocklet = new FileMakerClocklet();
        
        // Expose setTime method globally for FileMaker to call
        window.setClockletTime = (timeString) => clocklet.setTime(timeString);
        
        // Expose setWorkingHours method globally for FileMaker to call
        window.setClockletWorkingHours = (startHour, endHour) => clocklet.setWorkingHours(startHour, endHour);
    </script>
</body>
</html>
